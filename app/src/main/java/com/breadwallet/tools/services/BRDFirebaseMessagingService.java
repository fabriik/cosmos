package com.breadwallet.tools.services;

import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.support.annotation.RequiresApi;
import android.support.v4.app.NotificationCompat;
import android.util.Log;

import com.breadwallet.BreadApp;
import com.breadwallet.BuildConfig;
import com.breadwallet.R;
import com.breadwallet.presenter.activities.HomeActivity;
import com.breadwallet.protocols.messageexchange.MessageExchangeService;
import com.breadwallet.tools.manager.BRSharedPrefs;
import com.breadwallet.tools.threads.executor.BRExecutor;
import com.breadwallet.tools.util.BRConstants;
import com.breadwallet.tools.util.Utils;
import com.google.firebase.messaging.FirebaseMessagingService;
import com.google.firebase.messaging.RemoteMessage;
import com.platform.APIClient;

import org.json.JSONException;
import org.json.JSONObject;

import okhttp3.MediaType;
import okhttp3.Request;
import okhttp3.RequestBody;

/**
 * BreadWallet
 * <p/>
 * Created by Jade Byfield <jade@breadwallet.com> on 7/12/18.
 * Copyright (c) 2018 breadwallet LLC
 * <p/>
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * <p/>
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * <p/>
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * <p>
 * This class is responsible for updating the Firebase registration token each time a new one is available,
 * and receiving and displaying push notifications.
 */
public final class BRDFirebaseMessagingService extends FirebaseMessagingService {

    private static final String NOTIFICATION_TITLE = "title";
    private static final String NOTIFICATION_BODY = "body";
    private static final String ENDPOINT_PUSH_DEVICES = "/me/push-devices";
    private static final String PUSH_SERVICE = "fcm";
    private static final String KEY_TOKEN = "token";
    private static final String KEY_SERVICE = "service";
    private static final String KEY_DATA = "data";
    private static final String KEY_DATA_ENVIRONMENT = "e";
    private static final String KEY_DATA_BUNDLE_ID = "b";
    private static final String ENVIRONMENT_DEVELOPMENT = "d";
    private static final String ENVIRONMENT_PRODUCTION = "p";
    private final String NOTIFICATION_CHANNEL_ID = "brd_notifications_channel";
    private static final String TAG = BRDFirebaseMessagingService.class.getSimpleName();

    /**
     * @param token The new token that was generated by Firebase
     */
    @Override
    public void onNewToken(final String token) {
        super.onNewToken(token);
        Log.d(TAG, "onNewToken: token value -> " + token);

        // Save token in BRSharedPrefs
        BRSharedPrefs.putFCMRegistrationToken(this, token);

    }

    /**
     * @param remoteMessage Object containing the message/data payload of the push notification.
     */
    @Override
    public void onMessageReceived(RemoteMessage remoteMessage) {

        NotificationManager notificationManager =
                (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

        if (notificationManager != null) {
            //Setting up Notification channels for android O and above
            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                setupChannels(notificationManager);
            }
            int notificationId = getNextNotificationId();
            String notificationTitle = remoteMessage.getData().get(NOTIFICATION_TITLE);
            String notificationMessage = remoteMessage.getData().get(NOTIFICATION_BODY);

            // Take the user to HomeActivity upon tapping the notification
            Intent homeIntent = new Intent(this, HomeActivity.class);
            homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, homeIntent, 0);

            NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
                    .setSmallIcon(R.drawable.brd_logo_gradient)
                    .setContentTitle(notificationTitle)
                    .setContentText(notificationMessage)
                    .setAutoCancel(true)
                    .setContentIntent(pendingIntent);

            notificationManager.notify(notificationId, notificationBuilder.build());

        }
    }

    /**
     * Starting in Android 0(API 26), all notifications must be assigned to a channel.
     * In this case, we want to explicitly create a channel for PWB notifications
     *
     * @param notificationManager NotificationManager that will be used to set up the notification channel.
     */
    @RequiresApi(api = Build.VERSION_CODES.O)
    private void setupChannels(NotificationManager notificationManager) {
        NotificationChannel notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, getString(R.string.PushNotifications_title), NotificationManager.IMPORTANCE_DEFAULT);
        notificationChannel.setDescription(getString(R.string.PushNotifications_body));
        notificationManager.createNotificationChannel(notificationChannel);

    }


    /**
     * @param context
     */
    public static void updateFcmRegistrationToken(final Context context) {

        // Check if we currently have a Firebase Messenger token stored in Shared Prefs
        final String firebaseToken = BRSharedPrefs.getFCMRegistrationToken(context);

        // If so, send this token to our backend so that we can log this user device
        if (!Utils.isNullOrEmpty(firebaseToken)) {
            BRExecutor.getInstance().forLightWeightBackgroundTasks().execute(new Runnable() {
                @Override
                public void run() {

                    String url = BRConstants.HTTPS_PROTOCOL + BreadApp.HOST + ENDPOINT_PUSH_DEVICES;
                    String deviceEnvironment;

                    if (BuildConfig.DEBUG) {
                        deviceEnvironment = ENVIRONMENT_DEVELOPMENT;
                    } else {
                        deviceEnvironment = ENVIRONMENT_PRODUCTION;
                    }

                    try {

                        JSONObject payload = new JSONObject();
                        payload.put(KEY_TOKEN, firebaseToken);
                        payload.put(KEY_SERVICE, PUSH_SERVICE);

                        JSONObject data = new JSONObject();
                        data.put(KEY_DATA_ENVIRONMENT, deviceEnvironment);
                        data.put(KEY_DATA_BUNDLE_ID, context.getPackageName());
                        payload.put(KEY_DATA, data);

                        final MediaType JSON
                                = MediaType.parse(BRConstants.CONTENT_TYPE_JSON);

                        RequestBody requestBody = RequestBody.create(JSON, payload.toString());

                        Request request = new Request.Builder()
                                .url(url)
                                .header(BRConstants.HEADER_CONTENT_TYPE, BRConstants.CONTENT_TYPE_JSON)
                                .header(BRConstants.HEADER_ACCEPT, BRConstants.HEADER_VALUE_ACCEPT).post(requestBody).build();

                        APIClient.getInstance(context).sendRequest(request, true);

                    } catch (JSONException e) {
                        Log.e(TAG, "Error constructing JSON payload while updating FCM registration token.", e);
                    }
                }
            });

        }


    }

    /**
     * @return An incremented, unique notificationId to be used for each notification.
     */
    private synchronized int getNextNotificationId() {

        // Get the current stored Id
        int currentId = BRSharedPrefs.getNotificationId(this);

        // Increment the current Id and update SharedPrefs
        int newId = ++currentId;
        BRSharedPrefs.putNotificationId(this, newId);
        return newId;

    }

}
